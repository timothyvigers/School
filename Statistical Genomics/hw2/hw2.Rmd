---
title: "BIOS 7659 Homework 2"
author: "Tim Vigers"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE,cache=TRUE,message=FALSE)
knitr::opts_knit$set(root.dir="C:/Users/timbv/Documents/GitHub/School/Statistical Genomics/hw2")
library(knitr)
library(affy)
library(simpleaffy)
library(tidyverse)
```

# Quality Control

## a) Read the 8 CEL files

```{r import}
pd=read.AnnotatedDataFrame("./targets.txt" , header=TRUE,
                             row.names=1,as.is=TRUE)
Data=ReadAffy(filenames=pData(pd)$FileName, phenoData=pd,
                sampleNames=sampleNames(pd))
```

### Practice extracting information from data

```{r functions,warning=FALSE}
kable(head(exprs(Data)),digits=3)
sampleNames(Data)
head(probeNames(Data))
kable(head(mm(Data)),digits=3)
kable(head(pm(Data)),digits=3)
kable(pData(Data),digits=3)
```

## b) Plot the raw microarray images

```{r raw images}
image(Data)
```

For the most part nothing in these plots stands out, except for "Low 4." This array appears to be generally bright (washed out), with an oval patch of high fluorescence and a thin strip of probes with no fluorescence. It is not obvious exactly what happened, but it appears that the processing for this plate went wrong at some point.

## c) Plot quality control metrics

```{r plot qc}
plot.qc.stats(qc.affy(Data))
```

Interestingly, the quality control metrics appear to be reasonable based on this plot, even for array "Low4." The top number (a percentage) for each array is the present call, which is the percentage of genes reliably detected, and can be considered a measure of overall quality. In general these arrays appear to have similar percentages, which is a good sign. The bottom number represents average background level, and this appears to be pretty similar across arrays except for "High1" which has a much higher level than the rest. This suggests potential signal-to-noise problems with "High1." 

Also, it is a little bit surprising that the background for "Low4" is among the lower end of background values, because visual inspection suggested there was a lot of noise. The package automatically flags significantly different (by default defined as more than 10% difference for present call and 20 units for background) values in red. So in general these values are acceptable aside from the background value of "High1."

The GAPDH ratios (circles) and beta actin ratios (triangles) also appear reasonable for all arrays. In general, the triangles should be within 3-fold change and the circles within 1, and the `simpleaffy` package will again automatically flag values outside these ranges by coloring them red. Lastly, the horizontal line for each array represents the distance from 0-fold change to its scale factor. The ends of each line should be within the shaded blue region, so the scale factors for all of these plates are compatible. 

## d) Plot the mean intensity from 3' to 5' end of the target mRNA

```{r}
plotAffyRNAdeg(AffyRNAdeg(Data))
```

Probes in a probeset are ordered relative to the 5' end. Intensities are averaged by location across all probesets, for each array. Because RNA tends to start degradation at the 5' end, one would expect lower intensities at that end. Visual inspection of this plot suggests that RNA degradation is similar across all the arrays, but it's useful to check using `summaryAffyRNAdeg`, which provides a slope estimate and p value to accompany the above plot:

```{r}
summaryAffyRNAdeg(AffyRNAdeg(Data))
```

This confirms that RNA degradation appears to be fairly similar across all arrays.

## e) Examine the distribution of intensity values for the perfect-match and mismatch probes

### Perfect match

```{r}
boxplot(Data,which="pm")
plotDensity.AffyBatch(Data,which="pm")
```

### Mismatch

```{r}
boxplot(Data,which="mm")
plotDensity.AffyBatch(Data,which="mm")
```

For both sets of probes, the intensity tends to be elevated on "High1" compared to the other arrays. The rest of the arrays appear to be in pretty close agreement based on these plots, although "Low4" has a wider range than the others.

## f) Recommendations

Based on the QC plots and tables, "High1" requires further investigation at the very least. Its background level of intensity seems significantly different from the other arrays, but this should be fixed during the normalization step. It might also be worth looking into array "Low4" as well, because the raw image shows clear signs of processing error despite generally passing the QC steps above. Nothing should be excluded yet, but "High1" and "Low4" are candidates for exclusion at later steps and warrant extra attention.

# Normalization

## a) Plot log-transformed and non-transformed data

```{r}
plotDensity.AffyBatch(Data,log=F)
```

```{r}
plotDensity.AffyBatch(Data)
```

The plot with non-transformed data is almost impossible to read because the data are so skewed and the range is so large. Most intensity values are close to 0, but some are as high as 50,000. Again, one of the arrays seems a little different from the others in the log intensity plot. The distribution is approximately the same shape though, so hopefully normalization will fix this. 

## b) MA plots

```{r}
MAplot(Data)
```

The MA plots generally support the patterns observed in the QC plots, with most of the chips looking reasonably similar. However, "High1" is not clustered around the x-axis and the loess line is a little bit too high. This could be seen during QC as well, with intensity for that array being generally higher than the others, and the large background value in the `plot.qc.stats()` graph. 

Also, the MA plots clearly show the problems with the "Low4" array. The loess line is actually reasonably close to the x-axis (except maybe in the left tail), which might explain why some of the QC intensity plots didn't look too bad. However, there are points that form a thin straight line and another cloud, both at a pretty severe angle to the x-axis. You would have to assume that these are due to the obvious array defects that you can see in the raw image.   

## c) Using `expresso()`, try different methods

### Changing the normalization method

#### Non-normalized

```{r}
boxplot(Data)
```

#### Quantiles

```{r}
quantile_data <- expresso(Data,normalize.method="quantiles",
                          summary.method="avgdiff",
                          bgcorrect.method="rma",
                          pmcorrect.method="pmonly",
                          verbose=F)
boxplot(log(exprs(quantile_data),base=2))
```

#### Loess

```{r}
loess_data <- expresso(Data,normalize.method="loess",
                       summary.method="avgdiff",
                       bgcorrect.method="rma",
                       pmcorrect.method="pmonly",
                       verbose=F)
boxplot(log(exprs(loess_data),base=2))
```

#### Constant

```{r}
constant_data <- expresso(Data,normalize.method="constant",
                          summary.method="avgdiff",
                          bgcorrect.method="rma",
                          pmcorrect.method="pmonly",
                          verbose=F)
boxplot(log(exprs(constant_data),base=2))
```

Based on visual inspection of these boxplots, no normalization method appears to perform better than the others (at least not with `summary.method="avgdiff"`, `bgcorrect.method="rma"`, and `pmcorrect.method="pmonly"`). All of the arrays look similar to each other, and with all methods "High1" and "Low4" look much improved. However, the quantile method is much faster than the others. The loess method is particularly slow and should be avoided unless the other two methods cannot be used for some reason.

### Changing the summary method

The following plots are generated using the quantile normalization method, `pmcorrect.method="pmonly"`, and `bgcorrect.method="rma"` with different options for `summary.method`.

#### AvgDiff

```{r}
boxplot(log(exprs(quantile_data),base=2))
```

#### MAS

```{r}
mas_data <- expresso(Data,summary.method="mas",
                     normalize.method="quantiles",
                     bgcorrect.method="rma",
                     pmcorrect.method="pmonly",
                     verbose=F)
boxplot(log(exprs(mas_data),base=2))
```

#### Median polish

```{r}
median_data <- expresso(Data,summary.method="medianpolish",
                        normalize.method="quantiles",
                        bgcorrect.method="rma",
                        pmcorrect.method="pmonly",
                        verbose=F)
boxplot(log(exprs(median_data),base=2))
```

The MAS and AvgDiff boxplots look almost identical, but the median polish method does appear to be different from the other two. The median polish method produces expression values that are more normally distributed than those produced by the other methods. There were not noticeable differences in speed between the methods, so median polish is likely the best of these options (at least with the normalization, background, and PM correction methods selected).

### Changing the PM correction method

Using the quantile normalization method, `summary.method="medianpolish"`, and `bgcorrect.method="rma"`.

#### PM Only

```{r}
pmonly_data <- expresso(Data,pmcorrect.method="pmonly",
                        summary.method="medianpolish",
                        normalize.method="quantiles",
                        bgcorrect.method="rma",
                        verbose=F)
boxplot(log(exprs(pmonly_data),base=2))
```

#### MAS

```{r}
mas_data_2 <- expresso(Data,pmcorrect.method="mas",
                       summary.method="medianpolish",
                       normalize.method="quantiles",
                       bgcorrect.method="rma",
                       verbose=F)
boxplot(exprs(mas_data_2))
```

The plot above is on the natural scale because negative values cause problems for the log transformation. Also, it's concerning that the median polish function did not converge.

#### Subtract mismatch

```{r warning=FALSE}
subtractmm_data <- expresso(Data,pmcorrect.method="subtractmm",
                            summary.method="medianpolish",
                            normalize.method="quantiles",
                            bgcorrect.method="rma",
                            verbose=F)
boxplot(log(exprs(subtractmm_data),base=2))
```

Unfortunately, neither the MAS or subtract MM approaches seem to work well, at least not with the median polish summary method. The subtract MM plot looks reasonable, but it produces a lot of concerning "NaN" warnings that I suppressed in the output above. However, the PM only plot with median polish as the summary method looks excellent.

## d) Get present and absent calls

```{r}
# Presence/absence detection
calls <- mas5calls(Data)
# Get p values
calls_sig <- as.data.frame(assayData(calls)$exprs)
# Subset those with at least one significant p value in each group
filtered <- calls_sig %>% 
  filter(("P"==High1|"P"==High2|"P"==High3|"P"==High4)&
           ("P"==Low1|"P"==Low2|"P"==Low3|"P"==Low4))
```

After filtering there are `r nrow(filtered)` probesets left out of `r nrow(calls_sig)` (`r round(nrow(filtered)/nrow(calls_sig),3)*100`%).

## e) Problematic chips

Although most of the boxplots seem reasonable for "Low4," the MA plot in comparison to the pseudo-median chip suggests that it should be excluded. The bright oval and dark strip evident in the raw image are clearly represented in this plot, and this chip will likely be a detriment during normalization. Because the quantile method uses information from all the chips, it is important to exclude obvious problematic arrays before the normalization step.

However, the potential problems with "High1" appear to have been fixed by the normalization procedures:

```{r}
plotDensity(exprs(pmonly_data))
```

So the most appropriate approach seems to be to exclude "Low4" but keep "High1" in the dataset for analysis.

### Re-normalization

Import data without "Low4":

```{r}
pd=read.AnnotatedDataFrame("./targets_low4_excluded.txt" ,
                             header=TRUE,row.names=1,as.is=TRUE)
Data=ReadAffy(filenames=pData(pd)$FileName, phenoData=pd,
                sampleNames=sampleNames(pd))
```

Normalize using the subset from the filtering step d) above, and generate new plots:

```{r}
normalized <- rma(Data,subset=rownames(filtered))
plotDensity(exprs(normalized))
```

Save files of the intensities and calls locally:

```{r}
# Save normalized data
save(normalized,file="./normalized.R")
# Get calls and save
calls <- mas5calls(Data,ids=rownames(filtered))
save(calls,file="./calls.R")
```

Show the top lines:

```{r}
kable(head(exprs(normalized)),digits=3)
kable(head(assayData(calls)$exprs),digits=3)
```
