---
title: "BIOS 7659 Homework 5"
author: "Tim Vigers"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
knitr::opts_knit$set(root.dir="/home/tim/Documents/GitHub/School/Statistical Genomics/hw5")
library(RNASeqPower)
library(edgeR)
library(cqn)
library(yeastRNASeq)
library(EDASeq)
library(tidyverse)
```

# 1. Next Generation Sequencing (NGS): Sample Size Estimates

First, load the datasets into R:

```{r}
data(montgomery.subset)
data(uCovar)
```

## a) Recreate Figure 3 from the journal club paper

Figure 3 from Hart et al. shows the sample size needed to detect a two-fold difference in expression with 80% power and alpha = 0.01 for three different CV’s and a range of sequencing depths from 1 to 50.

# ALPHA = 0.05 OR 0.01?

```{r}
# Parameters
depths = seq(1,50)
effect = 2
alpha = 0.01
power = 0.8
# Calculate n
cv0.4 = rnapower(depths,cv = 0.4,effect = effect,alpha = alpha,power = power)
cv0.8 = rnapower(depths,cv = 0.8,effect = effect,alpha = alpha,power = power)
cv1.2 = rnapower(depths,cv = 1.2,effect = effect,alpha = alpha,power = power)
# Plotting data
fig3_data = as.data.frame(cbind(depths,cv0.4,cv0.8,cv1.2))
fig3_data = fig3_data %>% pivot_longer(cv0.4:cv1.2)
# Plot
ggplot(fig3_data,aes(x=depths,y=value,color=name)) + 
  geom_point() + geom_line() +
  theme_bw() + xlab("Gene Depth") + ylab("Samples Required") + 
  scale_color_discrete(name="",labels=c("CV = 0.4","CV = 0.8","CV = 1.2"))
```

This figure shows that as the gene depth increases, the required sample size decreases. After a depth of approximately 10, this effect tends to level off and the gains from increasing gene depth are minimal. Also, a higher coefficient of
variation (CV) across samples requires a higher sample size to achieve adequate power, as you would expect.

## b) Create a row for the Mongomery data in Table 1 in the Hart et al. paper.

```{r}
cols = c("Avg Reads","% mapped","< 0.01","0.01–.1","0.1–1","1–10","10–100","100–1000","> 1000")
table_1 = montgomery.subset %>% 
  summarise(ID="m",Sample="Montgomery",`Sample Type`="lymphoblastoid cell lines",
            n=ncol(.),`Read Type`="PE")
```

# WHAT ARE THE UNITS HERE? DO WE DIVIDE BY THE SUM OF THE COLUMN (IN MILLIONS)?

## c) Calculate the biological coefficient of variations (CV)

First, estimate the common dispersion using `estimateCommonDisp()`, then use this estimate for the dispersion parameter in `estimateTagwiseDisp()`. Plot a histogram and empirical CDF of these estimates, and print the quantiles:

```{r}
# Get common dispersion estimate
c = estimateCommonDisp(montgomery.subset)
# Estimate biological CV
e = estimateTagwiseDisp(montgomery.subset,dispersion = c)
# Histogram
hist(e,main="Histogram of Tagwise Dispersion Estimates",xlab = "Estimate")
plot(ecdf(e),main="Empirical CDF of Tagwise Dispersion Estimates",xlab="CV")
```

The median CV using this method is `r quantile(e,0.5)` and the 90th percentile is `r quantile(e,0.9)`. These estimates are quite a lot higher than the Hart paper human samples, which ranged "from 0.32 to 0.74 with a median of 0.43."

## d) Recreate Figure 3 from Hart et al. again

```{r}
# Calculate n
cv_median = rnapower(depths,cv = median(e),effect = effect,alpha = alpha,
                     power = power)
cv_90 = rnapower(depths,cv = quantile(e,0.9),effect = effect,alpha = alpha,
                 power = power)
# Plotting data
fig3_data_2 = as.data.frame(cbind(depths,cv_median,cv_90))
fig3_data_2 = fig3_data_2 %>% pivot_longer(cv_median:cv_90)
# Plot
ggplot(fig3_data_2,aes(x=depths,y=value,color=name)) + 
  geom_point() + geom_line() +
  theme_bw() + xlab("Gene Depth") + ylab("Samples Required") + 
  scale_color_discrete(name="",labels=c("Median CV","90th %ile CV"))
```

Based on the plot above and assuming gene depth of at least 10, I would recommend a sample size of approximately 380. Of course, these CV estimates appear to be fairly high, so if there is convincing evidence that the biological CV in the population under study would be lower than the median estimate, then a smaller sample size would be sufficient.

## e) Recreate the curve in the top of Figure 4

The curve we are trying to recreate is "the power curve for n = 20 per group, coverage of 100, $\sigma = 0.32$ (60th percentile of observed) and $\alpha = 0.001$":

```{r}
# Set parameters
n = 20
depth = 100
cv = quantile(e,0.6)
alpha = 0.001
effects = seq(1,8,0.01)
# Plot power as a function of fold change
p = rnapower(depth=depth,n=n,cv=cv,alpha=alpha,effect=effects)
plot_data = as.data.frame(cbind(effects,p))
ggplot(plot_data,aes(x=effects,y=p)) + geom_line() +
  theme_bw() + ylab("Power") + xlab("Fold Change")
```

# WHY WOULDN'T WE BE ABLE TO RECREATE THIS? DO WE NEED TO USE 60TH PERCENTILE OF OUR OBSERVED OR RECREATE USING THEIR CV VALUE? OR IS THIS REFERRING TO THE WEIRD Y AXIS IN THE HART FIGURE?

# 2. Next Generation Sequencing: Pre-Processing

First load the example data:

```{r}
data(geneLevelData)
data(yeastGC)
data(yeastLength)
```

## a) 

```{r}
all_zero = length(which(rowSums(geneLevelData)==0))
one_zero = length(which(rowSums(geneLevelData==0)>0))
```

Within `geneLevelData`, `r all_zero` genes have all 0 counts and `r one_zero` have at least one sample with a 0.

Now, create a filtered dataset (`geneLevelDataFilter`) with only genes containing $\geq$ 10 counts summed across all samples:

```{r}
geneLevelDataFilter = geneLevelData[which(rowSums(geneLevelData)>=10),]
```

Create a `SeqExpressionSet` object for the `EDASeq` functions:

```{r}
exprs = as.matrix(geneLevelDataFilter) # matrix of counts
sub = intersect(rownames(geneLevelDataFilter), names(yeastGC))
exprs = exprs[sub,] #only examine genes with annotated GC content/length
row.names(exprs) = NULL #remove row and column names
colnames(exprs) = NULL
#Create SeqExpressionSet, which contains counts, labels for the
#samples and GC content/length
counts = newSeqExpressionSet(counts=exprs,
phenoData=data.frame(conditions = factor(c("mut","mut","wt","wt"))),
featureData=AnnotatedDataFrame(data.frame(gc=yeastGC[sub],
length = yeastLength[sub])))
```

## b)

### Plot the counts by sample:

```{r}
EDASeq::boxplot(counts)
```

# EDA AUTOMATICALLY   DOES BOXPLOTS ON THE LOG SCALE RIGHT?

The two wildtype samples (3 and 4 above) do appear to be slightly different from the other two samples. Their distributions look slightly wider, and the medians appear to be slightly different as well, which indicates a need for normalization.

### Plot the mean by variance plot:

```{r}
meanVarPlot(counts,log=T)
```

Based on this plot it appears that as the mean increases so does the variance. The red lowess curve indicates that this relationship is particularly strong for a mean above 4 (on the log scale).

### Assess any biases by GC content

```{r}
biasPlot(counts,"gc",log=TRUE)
```

Based on the above plot, it appears that there is GC bias in this dataset because the wildtype samples generally appear to have a higher proportion of GC than the mutants.

### Assess any biases by length

```{r}
biasPlot(counts,"length",log=TRUE)
```

Overall there doesn't appear to be much bias by length. As gene length goes above 10,000, the wildtype samples tend to have fewer counts than the mutants but it does not appear to be particularly drastic in this dataset.

## c) Apply `withinLaneNormalization()` to normalize by GC content

The `withinLaneNormalization()` function has four options for normalization: loess, median, full, and upper. The loess approach regresses the counts on the GC proportion and then subtracts the loess line from the counts. The median, upper, and full methods stratify genes into a given number of bins (10 being the default) based on GC content. Then the median approaches scales the data so each bin has the same median, the upper does the same but for the upper quartile instead of the median, and the full method "forces the distribution of each stratum to be the same using a non linear full quantile normalization." 

### Loess method

```{r}
loess = withinLaneNormalization(counts,"gc",which = "loess")
biasPlot(loess,"gc",log=TRUE)
```

### Full method

```{r}
full = withinLaneNormalization(counts,"gc",which = "full")
biasPlot(full,"gc",log=TRUE)
```

### Upper method

```{r}
upper = withinLaneNormalization(counts,"gc",which = "upper")
biasPlot(upper,"gc",log=TRUE)
```

### Median method

```{r}
median = withinLaneNormalization(counts,"gc",which = "median")
biasPlot(median,"gc",log=TRUE)
```

## d) Apply `betweenLaneNormalization()` to normalize across samples

This method is similar to the `withinLaneNormalization()` function, but does not include a loess method. Instead of normalizing bins within a lane, however, these methods ensure that the lanes are similar. So, the median approach forces the median of all the lanes to the be the same, the upper approach does the same but using the upper quartile rather than the median, and the full method uses the full quantile method. 

### Loess within-lane normalization

#### Median between-lane normalization

```{r}
loess_median = betweenLaneNormalization(loess,"median")
boxplot(loess_median)
```

#### Upper between-lane normalization

```{r}
loess_upper = betweenLaneNormalization(loess,"upper")
boxplot(loess_upper)
```

#### Full between-lane normalization

```{r}
loess_full = betweenLaneNormalization(loess,"full")
boxplot(loess_full)
```

### Median within-lane normalization

#### Median between-lane normalization

```{r}
median_median = betweenLaneNormalization(median,"median")
boxplot(median_median)
```

#### Upper between-lane normalization

```{r}
median_upper = betweenLaneNormalization(median,"upper")
boxplot(median_upper)
```

#### Full between-lane normalization

```{r}
median_full = betweenLaneNormalization(median,"full")
boxplot(median_full)
```

### Upper within-lane normalization

#### Median between-lane normalization

```{r}
upper_median = betweenLaneNormalization(upper,"median")
boxplot(upper_median)
```

#### Upper between-lane normalization

```{r}
upper_upper = betweenLaneNormalization(upper,"upper")
boxplot(upper_upper)
```

#### Full between-lane normalization

```{r}
upper_full = betweenLaneNormalization(upper,"full")
boxplot(upper_full)
```

### Full within-lane normalization

#### Median between-lane normalization

```{r}
full_median = betweenLaneNormalization(full,"median")
boxplot(full_median)
```

#### Upper between-lane normalization

```{r}
full_upper = betweenLaneNormalization(full,"upper")
boxplot(full_upper)
```

#### Full between-lane normalization

```{r}
full_full = betweenLaneNormalization(full,"full")
boxplot(full_full)
```